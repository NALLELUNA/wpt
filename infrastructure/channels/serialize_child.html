<!doctype html>
<script src="/resources/channel.sub.js"></script>
<script src="serialize-data.js"></script>
<script>

let lastData;

// Hack: these will be recreated as assert failures in the caller
function AssertionError(message) {
    this.message = message;
}
AssertionError.prototype = Object.create(Error.prototype);

function compareResult(name, actual) {
    let obj = objects[name]
    let expected = obj.hasOwnProperty("output") ? obj.output : obj.input;
    seen = new Set();
    try {
        compareValue(actual, expected, seen);
    } catch(e) {
        throw new AssertionError(e.message);
    }
    return true;
}

function compareValue(actualValue, expectedValue, seen) {
    if (typeof actualValue != typeof expectedValue) {
        throw new Error(`Types differ, expected ${typeof expectedValue}, got ${typeof actualValue}`);
    }
    if (["undefined", "string", "boolean", "number", "bigint"].includes(typeof expectedValue) ||
        actualValue === null) {
        if (Number.isNaN(expectedValue)) {
            if (!Number.isNaN(actualValue)) {
                throw new Error("Expected NaN, got $(actual)");
            }
        } else if (actualValue !== expectedValue) {
            throw new Error(`Expected ${typeof expected} ${expected}, got ${actual}`);
        }
        return;
    }

    if (expectedValue.constructor && actualValue.constructor && expectedValue.constructor.name !== actualValue.constructor.name) {
        throw new Error(`Constructors differ, expected ${expectedValue.constructor.name}, got ${actualValue.constructor.name}`);
    }
    if (expectedValue.constructor.name === "SendChannel") {
        if (expectedValue.uuid !== actualValue.uuid) {
            throw new Error(`SendChannels differ, expected uuid ${expectedValue.uuid}, got ${actualValue.uuid}`);
        }
    }
    else if (expectedValue.constructor.name === "RegExp") {
        if (expectedValue.source !== actualValue.source ||
            expectedValue.flags !== actualValue.flags) {
            throw new Error(`Regexps differ, expected ${expectedValue}, got ${actualValue}`);
        }
    } else if (expectedValue.constructor.name == "Date") {
        if (expectedValue.toDateString() !== actualValue.toDateString()) {
            throw new Error(`Dates differ, expected ${expectedValue.toDateString()}, got ${actualValue.toDateString()}`);
        }
    } else if (expectedValue instanceof Error) {
        if (expectedValue.message !== actualValue.message ||
            expectedValue.lineNumber !== actualValue.lineNumber ||
            expectedValue.columnNumber !== actualValue.columnNumber ||
            expectedValue.fileName !== actualValue.fileName) {
            throw new Error(`Errors differ, expected ${expectedValue}, got ${actualValue}`);
        }
    } else if (Array.isArray(expectedValue)) {
        seenActual = seen.has(actualValue);
        seenExpected = seen.has(expectedValue)
        if (seenActual && seenExpected) {
            return;
        } else if (seenExpected && !seenActual) {
            throw new Error(`Expected cyclic array`);
        } else if (!seenExpected && seenActual) {
            throw new Error(`Got unexpected cyclic array`);
        }
        seen.add(actualValue);
        seen.add(expectedValue);

        if (actualValue.length !== expectedValue.length) {
            throw new Error(`Array lengths differ, expected ${expectedValue.length}, got ${actualValue.length}`);
        }
        for (let i=0; i<actualValue.length; i++) {
            compareValue(actualValue[i], expectedValue[i], seen);
        }
    } else if (expectedValue.constructor.name === "Set") {
        seenActual = seen.has(actualValue);
        seenExpected = seen.has(expectedValue)
        if (seenActual && seenExpected) {
            return;
        } else if (seenExpected && !seenActual) {
            throw new Error(`Expected cyclic set`);
        } else if (!seenExpected && seenActual) {
            throw new Error(`Got unexpected cyclic set`);
        }
        seen.add(actualValue);
        seen.add(expectedValue);


        if (actualValue.size !== expectedValue.size) {
            throw new Error(`Set sizes differ, expected ${expectedValue.size}, got ${actualValue.size}`);
        }
        // So for a set we can't really check if the values are the same
        // except where they're primitives
        for (let entry of expectedValue) {
            if (["undefined", "string", "boolean", "number", "bigint"].includes(typeof entry) || entry === null) {
                if(!actualValue.has(entry)) {
                    throw new Error(`Set missing entry, expected ${entry}`);
                }
            } else {
                throw new Error(`Can't compare non-primitive value ${entry} inside sets`);
            }
        }
    } else if (expectedValue.constructor.name === "Map") {
        seenActual = seen.has(actualValue);
        seenExpected = seen.has(expectedValue)
        if (seenActual && seenExpected) {
            return;
        } else if (seenExpected && !seenActual) {
            throw new Error(`Expected cyclic map`);
        } else if (!seenExpected && seenActual) {
            throw new Error(`Got unexpected cyclic map`);
        }
        seen.add(actualValue);
        seen.add(expectedValue);

        if (actualValue.size !== expectedValue.size) {
            throw new Error(`Map sizes differ, expected ${expectedValue.size}, got ${actualValue.size}`);
        }
        // So for a set we can't really check if the values are the same
        // except where they're primitives
        for (let [key, value] of expectedValue.entries()) {
            if(!actualValue.has(key)) {
                throw new Error(`Map missing key, expected key ${key} with value ${value}`);
            }
            compareValue(actualValue.get(key), value, seen);
        }
    } else {
        seenActual = seen.has(actualValue);
        seenExpected = seen.has(expectedValue)
        if (seenActual && seenExpected) {
            return;
        } else if (seenExpected && !seenActual) {
            throw new Error(`Expected cyclic object`);
        } else if (!seenExpected && seenActual) {
            throw new Error(`Got unexpected cyclic object`);
        }
        seen.add(actualValue);
        seen.add(expectedValue);


        // Compare as a general Object
        if (Object.keys(actualValue).length !== Object.keys(expectedValue).length) {
            throw new Error(`Object keys differ, expected [${Object.keys(expectedValue).join(",")}], got [${Object.keys(actualValue).join(",")}]`);
        }
        // So for a set we can't really check if the values are the same
        // except where they're primitives
        for (let [name, entry] of Object.entries(expectedValue)) {
            if(!actualValue.hasOwnProperty(name)) {
                throw new Error(`Object missing key ${name}`);
            }
            compareValue(actualValue[name], entry, seen);
        }
    }
}

ctx = start_window_channel();
</script>
